<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ§™ å·«å¸ˆç‰Œ Online</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a472a 0%, #2d5a3f 100%);
      min-height: 100vh;
      color: white;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }
    
    /* ä¸»é¡µæ ·å¼ */
    .home-screen {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }
    
    .home-card {
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 40px;
      max-width: 400px;
      width: 100%;
      text-align: center;
    }
    
    .home-card h1 {
      margin-bottom: 10px;
    }
    
    .home-card p {
      opacity: 0.8;
      margin-bottom: 30px;
    }
    
    input[type="text"] {
      width: 100%;
      padding: 15px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.3);
      font-size: 16px;
      background: rgba(255,255,255,0.95);
      color: #1a1a2e;
      margin-bottom: 15px;
    }
    
    input[type="text"]::placeholder {
      color: #666;
    }
    
    .btn {
      padding: 15px 30px;
      border-radius: 10px;
      border: none;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    
    .btn:hover {
      transform: translateY(-2px);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      width: 100%;
    }
    
    .btn-success {
      background: #4ade80;
      color: #1a472a;
    }
    
    .btn-outline {
      background: transparent;
      border: 2px solid rgba(255,255,255,0.3);
      color: white;
    }
    
    .join-row {
      display: flex;
      gap: 10px;
    }
    
    .join-row input {
      flex: 1;
      margin-bottom: 0;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    .error-msg {
      color: #f87171;
      margin-top: 15px;
    }
    
    /* å¤§å…æ ·å¼ */
    .lobby-screen {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }
    
    .lobby-card {
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 40px;
      max-width: 500px;
      width: 100%;
      text-align: center;
    }
    
    .room-code-box {
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }
    
    .room-code-box .label {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .room-code-box .code {
      font-size: 36px;
      font-weight: bold;
      letter-spacing: 8px;
    }
    
    .room-code-box .hint {
      font-size: 12px;
      opacity: 0.6;
      margin-top: 5px;
    }
    
    .player-list {
      margin-bottom: 20px;
    }
    
    .player-item {
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 10px 15px;
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .player-item.me {
      background: rgba(255,215,0,0.2);
    }
    
    .host-badge {
      font-size: 12px;
      background: #ffd700;
      color: #1a1a2e;
      padding: 2px 8px;
      border-radius: 4px;
    }
    
    /* æ¸¸æˆç•Œé¢æ ·å¼ */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .info-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.2);
      border-radius: 12px;
      padding: 10px 20px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .turn-indicator {
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    .turn-indicator.my-turn {
      background: #ffd700;
      color: #1a1a2e;
      font-weight: bold;
    }
    
    .score-board {
      display: flex;
      justify-content: space-around;
      background: rgba(0,0,0,0.2);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .player-score {
      text-align: center;
      padding: 5px 15px;
      border-radius: 8px;
    }
    
    .player-score.current {
      background: rgba(255,215,0,0.3);
    }
    
    .player-score.me {
      border: 2px solid rgba(100,200,255,0.5);
      background: rgba(100,200,255,0.2);
    }
    
    .player-score .name {
      font-weight: bold;
    }
    
    .player-score .stats {
      font-size: 14px;
    }
    
    .trick-area {
      background: rgba(0,0,0,0.3);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 15px;
      min-height: 160px;
    }
    
    .trick-area .title {
      text-align: center;
      margin-bottom: 10px;
      font-size: 14px;
    }
    
    .trick-cards {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .trick-card-wrapper {
      text-align: center;
    }
    
    .trick-card-wrapper .player-name {
      font-size: 12px;
      margin-top: 5px;
    }
    
    /* å¡ç‰Œæ ·å¼ */
    .card {
      width: 70px;
      height: 100px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px solid #ddd;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    
    .card.small {
      width: 50px;
      height: 75px;
      font-size: 14px;
    }
    
    .card.normal {
      background: white;
    }
    
    .card.wizard {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .card.jester {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }
    
    .card.selected {
      border: 3px solid #ffd700;
      box-shadow: 0 0 10px #ffd700;
      transform: translateY(-10px);
    }
    
    .card.disabled {
      opacity: 0.6;
      cursor: default;
    }
    
    .card .rank {
      font-size: 20px;
    }
    
    .card .suit {
      font-size: 28px;
    }
    
    .card.small .rank {
      font-size: 14px;
    }
    
    .card.small .suit {
      font-size: 20px;
    }
    
    .card .special-icon {
      font-size: 32px;
    }
    
    .card .special-name {
      font-size: 12px;
    }
    
    .card.small .special-icon {
      font-size: 24px;
    }
    
    .card.small .special-name {
      font-size: 10px;
    }
    
    .suit-spade, .suit-club {
      color: #1a1a2e;
    }
    
    .suit-heart, .suit-diamond {
      color: #e63946;
    }
    
    /* å«ç‰ŒåŒºåŸŸ */
    .bid-area {
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .bid-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 15px;
    }
    
    .bid-btn {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .bid-btn:disabled {
      background: #666;
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* æ‰‹ç‰ŒåŒºåŸŸ */
    .hand-area {
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px;
    }
    
    .hand-area .title {
      text-align: center;
      margin-bottom: 10px;
    }
    
    .hand-cards {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
    }
    
    .play-hint {
      text-align: center;
      margin-top: 10px;
      font-size: 14px;
    }
    
    /* ç»“ç®—ç•Œé¢ */
    .round-end, .game-end {
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 30px;
      text-align: center;
    }
    
    .score-table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
    }
    
    .score-table th, .score-table td {
      padding: 10px;
    }
    
    .score-table .positive {
      color: #4ade80;
      font-weight: bold;
    }
    
    .score-table .negative {
      color: #f87171;
      font-weight: bold;
    }
    
    .final-ranking {
      margin-top: 20px;
    }
    
    .rank-item {
      padding: 15px;
      margin: 10px 0;
      border-radius: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .rank-item.first {
      background: linear-gradient(135deg, #ffd700 0%, #ffed4a 100%);
      color: #1a1a2e;
    }
    
    .rank-item.me {
      background: rgba(100,200,255,0.2);
    }
    
    .rank-item:not(.first):not(.me) {
      background: rgba(0,0,0,0.2);
    }
    
    .rank-icon {
      font-size: 24px;
    }
    
    .rank-name {
      font-weight: bold;
      font-size: 18px;
    }
    
    .rank-score {
      font-size: 20px;
      font-weight: bold;
    }
    
    /* è§„åˆ™è¯´æ˜ */
    details {
      margin-top: 30px;
      text-align: left;
      font-size: 14px;
      opacity: 0.9;
    }
    
    details summary {
      cursor: pointer;
    }
    
    details p {
      margin: 5px 0;
      line-height: 1.6;
    }
    
    .waiting-msg {
      padding: 15px;
      opacity: 0.8;
    }
    
    .trump-suit {
      font-size: 24px;
    }
    
    .hidden {
      display: none !important;
    }

    /* AI æ¨¡å¼æ ·å¼ */
    .ai-badge {
      font-size: 12px;
      background: rgba(100,200,255,0.3);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 5px;
    }

    @keyframes thinking {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .thinking {
      animation: thinking 1s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  
  <script>
    // Firebase é…ç½®
    const firebaseConfig = {
      apiKey: "AIzaSyC-uJI8ORwdGI-slYoa0Qo4EGHsew3odWM",
      authDomain: "wizard-game-8909d.firebaseapp.com",
      databaseURL: "https://wizard-game-8909d-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "wizard-game-8909d",
      storageBucket: "wizard-game-8909d.firebasestorage.app",
      messagingSenderId: "819480038608",
      appId: "1:819480038608:web:6fbc646f35ccc4184b62d5",
      measurementId: "G-PJF0052EFR"
    };

    // åˆå§‹åŒ– Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // æ¸¸æˆå¸¸é‡
    const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
    const SUIT_COLORS = { 'â™ ': 'suit-spade', 'â™¥': 'suit-heart', 'â™¦': 'suit-diamond', 'â™£': 'suit-club' };
    const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

    // æ¸¸æˆçŠ¶æ€
    let playerId = sessionStorage.getItem('wizardPlayerId');
    if (!playerId) {
      playerId = 'player_' + Math.random().toString(36).substr(2, 9);
      sessionStorage.setItem('wizardPlayerId', playerId);
    }
    
    let playerName = '';
    let roomCode = '';
    let gameState = null;
    let myIndex = -1;
    let selectedCard = null;
    let unsubscribe = null;
    let isAIGame = false;
    let aiPlayerCount = 3;
    let aiDifficulty = 'normal'; // easy, normal, hard
    let aiThinking = false;

    // ç”Ÿæˆæˆ¿é—´ç 
    function generateRoomCode() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let code = '';
      for (let i = 0; i < 6; i++) {
        code += chars[Math.floor(Math.random() * chars.length)];
      }
      return code;
    }

    // åˆ›å»ºç‰Œç»„
    function createDeck() {
      const deck = [];
      for (let i = 0; i < 4; i++) {
        deck.push({ type: 'wizard', id: `wizard-${i}` });
      }
      for (let i = 0; i < 4; i++) {
        deck.push({ type: 'jester', id: `jester-${i}` });
      }
      for (const suit of SUITS) {
        for (const rank of RANKS) {
          deck.push({
            type: 'normal',
            suit,
            rank,
            id: `${suit}-${rank}`,
            value: RANKS.indexOf(rank)
          });
        }
      }
      return deck;
    }

    // å¸¦ç§å­çš„éšæœºæ•°
    function seededRandom(seed) {
      const x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    // æ´—ç‰Œ
    function shuffleDeck(deck, seed) {
      const shuffled = [...deck];
      let currentSeed = seed;
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // è®¡ç®—åˆ†æ•°
    function calculateScore(bid, tricks) {
      if (bid === tricks) {
        return 20 + tricks * 10;
      } else {
        return -Math.abs(bid - tricks) * 10;
      }
    }

    // ===================== AI é€»è¾‘ =====================

    // AI åå­—
    const AI_NAMES = ['å°æ™º', 'é˜¿å°”æ³•', 'æ·±è“', 'æ²ƒæ£®', 'å°å†°', 'å¤©çŒ«ç²¾çµ'];

    // è¯„ä¼°æ‰‹ç‰Œå¼ºåº¦
    function evaluateHand(hand, trumpSuit) {
      let expectedWins = 0;

      for (const card of hand) {
        if (card.type === 'wizard') {
          expectedWins += 1;
        } else if (card.type === 'jester') {
          expectedWins += 0;
        } else if (card.type === 'normal') {
          // ç‹ç‰Œ
          if (card.suit === trumpSuit) {
            if (card.value >= 10) expectedWins += 0.9; // A, K
            else if (card.value >= 8) expectedWins += 0.7; // Q, J
            else if (card.value >= 6) expectedWins += 0.5;
            else expectedWins += 0.3;
          } else {
            // éç‹ç‰Œ
            if (card.value >= 12) expectedWins += 0.6; // A
            else if (card.value >= 10) expectedWins += 0.4; // K, Q
            else if (card.value >= 8) expectedWins += 0.2;
            else expectedWins += 0.05;
          }
        }
      }

      return expectedWins;
    }

    // AI å«ç‰Œç­–ç•¥
    function aiDecideBid(playerIndex, state) {
      const player = state.players[playerIndex];
      const hand = player.hand;
      const trumpSuit = state.trumpSuit;
      const round = state.round;

      let expectedWins = evaluateHand(hand, trumpSuit);

      // æ ¹æ®éš¾åº¦è°ƒæ•´
      if (aiDifficulty === 'easy') {
        expectedWins += (Math.random() - 0.5) * 2;
      } else if (aiDifficulty === 'hard') {
        // æ›´ç²¾å‡†çš„è¯„ä¼°
        expectedWins = Math.round(expectedWins);
      }

      let bid = Math.round(expectedWins);
      bid = Math.max(0, Math.min(round, bid));

      // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªå«ç‰Œè€…
      const numPlayers = state.players.length;
      const isLastBidder = playerIndex === state.dealer;

      if (isLastBidder) {
        const totalBids = state.players.reduce((sum, p) => sum + (p.bid || 0), 0);
        // æœ€åä¸€ä¸ªä¸èƒ½è®©æ€»é¢„æµ‹ç­‰äºç‰Œæ•°
        if (totalBids + bid === round) {
          bid = bid > 0 ? bid - 1 : bid + 1;
          bid = Math.max(0, Math.min(round, bid));
        }
      }

      return bid;
    }

    // AI å‡ºç‰Œç­–ç•¥
    function aiDecidePlay(playerIndex, state) {
      const player = state.players[playerIndex];
      const hand = player.hand;
      const trumpSuit = state.trumpSuit;
      const leadSuit = state.leadSuit;
      const currentTrick = state.currentTrick || [];
      const bid = player.bid;
      const tricks = player.tricks;
      const needMoreTricks = tricks < bid;

      // è·å–å¯å‡ºçš„ç‰Œ
      let playableCards = hand;
      if (leadSuit) {
        const followCards = hand.filter(c => c.type === 'normal' && c.suit === leadSuit);
        if (followCards.length > 0) {
          playableCards = [...followCards, ...hand.filter(c => c.type !== 'normal')];
        }
      }

      if (playableCards.length === 0) return hand[0];
      if (playableCards.length === 1) return playableCards[0];

      // åˆ†ç±»æ‰‹ç‰Œ
      const wizards = playableCards.filter(c => c.type === 'wizard');
      const jesters = playableCards.filter(c => c.type === 'jester');
      const normalCards = playableCards.filter(c => c.type === 'normal');
      const trumpCards = normalCards.filter(c => c.suit === trumpSuit);
      const leadCards = normalCards.filter(c => c.suit === leadSuit);
      const otherCards = normalCards.filter(c => c.suit !== trumpSuit && c.suit !== leadSuit);

      // åˆ¤æ–­å½“å‰è°èµ¢
      let currentWinnerValue = -1;
      let canWinWithNormal = false;

      if (currentTrick.length > 0) {
        const hasWizard = currentTrick.some(p => p.card.type === 'wizard');
        if (!hasWizard) {
          // è®¡ç®—å½“å‰æœ€å¤§ç‰Œ
          for (const play of currentTrick) {
            const card = play.card;
            if (card.type === 'normal') {
              let value = card.value;
              if (card.suit === trumpSuit) value += 100;
              else if (card.suit === leadSuit) value += 50;
              if (value > currentWinnerValue) currentWinnerValue = value;
            }
          }
          canWinWithNormal = true;
        }
      }

      // ç­–ç•¥
      if (needMoreTricks) {
        // éœ€è¦èµ¢ç‰Œ
        if (currentTrick.length === 0) {
          // é¦–å‡º
          if (wizards.length > 0 && aiDifficulty !== 'easy') {
            return wizards[0];
          }
          if (trumpCards.length > 0) {
            return trumpCards.reduce((a, b) => a.value > b.value ? a : b);
          }
          if (normalCards.length > 0) {
            return normalCards.reduce((a, b) => a.value > b.value ? a : b);
          }
        } else {
          // è·Ÿç‰Œ
          if (canWinWithNormal) {
            // å°è¯•ç”¨æœ€å°èƒ½èµ¢çš„ç‰Œ
            const winningCards = normalCards.filter(c => {
              let value = c.value;
              if (c.suit === trumpSuit) value += 100;
              else if (c.suit === leadSuit) value += 50;
              return value > currentWinnerValue;
            });

            if (winningCards.length > 0) {
              return winningCards.reduce((a, b) => {
                let va = a.value + (a.suit === trumpSuit ? 100 : a.suit === leadSuit ? 50 : 0);
                let vb = b.value + (b.suit === trumpSuit ? 100 : b.suit === leadSuit ? 50 : 0);
                return va < vb ? a : b;
              });
            }

            if (wizards.length > 0) return wizards[0];
          } else {
            // å·²æœ‰å·«å¸ˆï¼Œå‡ºå°ç‰Œ
            if (jesters.length > 0) return jesters[0];
            if (otherCards.length > 0) return otherCards.reduce((a, b) => a.value < b.value ? a : b);
            if (normalCards.length > 0) return normalCards.reduce((a, b) => a.value < b.value ? a : b);
          }
        }
      } else {
        // ä¸éœ€è¦èµ¢ç‰Œï¼Œå‡ºå°ç‰Œ
        if (jesters.length > 0) return jesters[0];
        if (currentTrick.length > 0 && !canWinWithNormal) {
          // å·²æœ‰å·«å¸ˆï¼Œéšä¾¿å‡º
          if (otherCards.length > 0) return otherCards.reduce((a, b) => a.value < b.value ? a : b);
        }
        if (otherCards.length > 0) return otherCards.reduce((a, b) => a.value < b.value ? a : b);
        if (leadCards.length > 0) {
          // å‡ºæœ€å°çš„è·Ÿç‰Œ
          const losingCards = leadCards.filter(c => c.value + 50 < currentWinnerValue);
          if (losingCards.length > 0) return losingCards.reduce((a, b) => a.value < b.value ? a : b);
          return leadCards.reduce((a, b) => a.value < b.value ? a : b);
        }
        if (normalCards.length > 0) return normalCards.reduce((a, b) => a.value < b.value ? a : b);
      }

      // é»˜è®¤è¿”å›ç¬¬ä¸€å¼ å¯å‡ºçš„ç‰Œ
      return playableCards[0];
    }

    // AI æ‰§è¡Œå›åˆ
    async function aiTakeTurn() {
      if (!isAIGame || !gameState || aiThinking) return;
      if (gameState.currentPlayer === myIndex) return;
      if (gameState.phase !== 'bidding' && gameState.phase !== 'playing') return;

      aiThinking = true;

      // æ¨¡æ‹Ÿæ€è€ƒå»¶è¿Ÿ
      const delay = aiDifficulty === 'easy' ? 500 : aiDifficulty === 'hard' ? 1500 : 1000;
      await new Promise(r => setTimeout(r, delay));

      const currentAI = gameState.currentPlayer;

      if (gameState.phase === 'bidding') {
        const bid = aiDecideBid(currentAI, gameState);
        await handleAIBid(currentAI, bid);
      } else if (gameState.phase === 'playing') {
        const card = aiDecidePlay(currentAI, gameState);
        await handleAIPlay(currentAI, card);
      }

      aiThinking = false;
    }

    // AI å«ç‰Œ
    async function handleAIBid(playerIndex, bidAmount) {
      const newState = JSON.parse(JSON.stringify(gameState));
      newState.players[playerIndex].bid = bidAmount;

      const numPlayers = newState.players.length;

      if (newState.players.every(p => p.bid !== null)) {
        newState.phase = 'playing';
        newState.currentPlayer = (newState.dealer + 1) % numPlayers;
      } else {
        newState.currentPlayer = (newState.currentPlayer + 1) % numPlayers;
      }

      gameState = newState;
      render();

      // ç»§ç»­ä¸‹ä¸€ä¸ª AI
      setTimeout(aiTakeTurn, 100);
    }

    // AI å‡ºç‰Œ
    async function handleAIPlay(playerIndex, card) {
      const newState = JSON.parse(JSON.stringify(gameState));
      const playerHand = newState.players[playerIndex].hand;
      const cardIndex = playerHand.findIndex(c => c.id === card.id);

      if (cardIndex === -1) return;

      playerHand.splice(cardIndex, 1);
      if (!newState.currentTrick) newState.currentTrick = [];
      newState.currentTrick.push({ player: playerIndex, card });

      if (newState.currentTrick.length === 1) {
        newState.leadSuit = card.type === 'normal' ? card.suit : null;
      } else if (!newState.leadSuit && card.type === 'normal') {
        newState.leadSuit = card.suit;
      }

      const numPlayers = newState.players.length;

      if (newState.currentTrick.length === numPlayers) {
        const winnerIndex = determineTrickWinner(newState.currentTrick, newState.trumpSuit);
        const winner = newState.currentTrick[winnerIndex].player;
        newState.players[winner].tricks++;

        if (newState.players[0].hand.length === 0) {
          newState.players = newState.players.map(p => ({
            ...p,
            score: p.score + calculateScore(p.bid, p.tricks)
          }));
          newState.phase = 'roundEnd';
        } else {
          newState.currentTrick = [];
          newState.leadSuit = null;
          newState.currentPlayer = winner;
        }
      } else {
        newState.currentPlayer = (newState.currentPlayer + 1) % numPlayers;
      }

      gameState = newState;
      render();

      // ç»§ç»­ä¸‹ä¸€ä¸ª AI
      setTimeout(aiTakeTurn, 100);
    }

    // ===================== AI é€»è¾‘ç»“æŸ =====================

    // åˆ¤æ–­ä¸€å¢©èµ¢å®¶
    function determineTrickWinner(trick, trumpSuit) {
      const firstWizardIndex = trick.findIndex(play => play.card.type === 'wizard');
      if (firstWizardIndex !== -1) return firstWizardIndex;

      let maxTrumpValue = -1;
      let trumpWinnerIndex = -1;
      for (let i = 0; i < trick.length; i++) {
        const card = trick[i].card;
        if (card.type === 'normal' && card.suit === trumpSuit && card.value > maxTrumpValue) {
          maxTrumpValue = card.value;
          trumpWinnerIndex = i;
        }
      }
      if (trumpWinnerIndex !== -1) return trumpWinnerIndex;

      let effectiveLeadSuit = null;
      for (const play of trick) {
        if (play.card.type === 'normal') {
          effectiveLeadSuit = play.card.suit;
          break;
        }
      }

      if (effectiveLeadSuit) {
        let maxLeadValue = -1;
        let leadWinnerIndex = 0;
        for (let i = 0; i < trick.length; i++) {
          const card = trick[i].card;
          if (card.type === 'normal' && card.suit === effectiveLeadSuit && card.value > maxLeadValue) {
            maxLeadValue = card.value;
            leadWinnerIndex = i;
          }
        }
        return leadWinnerIndex;
      }

      return 0;
    }

    // å‘ç‰Œ
    function dealCards(state, roundNum, dealerNum) {
      const deck = shuffleDeck(createDeck(), state.seed + roundNum);
      const cardsPerPlayer = roundNum;
      const numPlayers = state.players.length;

      state.players = state.players.map((p, i) => ({
        ...p,
        hand: deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer),
        bid: null,
        tricks: 0,
      }));

      const trumpIndex = numPlayers * cardsPerPlayer;
      if (trumpIndex < deck.length) {
        state.trumpCard = deck[trumpIndex];
        if (state.trumpCard.type === 'wizard') {
          state.trumpSuit = SUITS[Math.floor(seededRandom(state.seed + roundNum + 1000) * 4)];
        } else if (state.trumpCard.type === 'jester') {
          state.trumpSuit = null;
        } else {
          state.trumpSuit = state.trumpCard.suit;
        }
      } else {
        state.trumpCard = null;
        state.trumpSuit = null;
      }

      state.round = roundNum;
      state.dealer = dealerNum;
      state.currentPlayer = (dealerNum + 1) % numPlayers;
      state.currentTrick = [];
      state.leadSuit = null;
      state.phase = 'bidding';
    }

    // æ¸²æŸ“å¡ç‰Œ
    function renderCard(card, options = {}) {
      const { small, selected, disabled, onClick } = options;
      const sizeClass = small ? 'small' : '';
      const selectedClass = selected ? 'selected' : '';
      const disabledClass = disabled ? 'disabled' : '';
      
      let typeClass = 'normal';
      let content = '';
      
      if (card.type === 'wizard') {
        typeClass = 'wizard';
        content = `<div class="special-icon">ğŸ§™</div><div class="special-name">å·«å¸ˆ</div>`;
      } else if (card.type === 'jester') {
        typeClass = 'jester';
        content = `<div class="special-icon">ğŸƒ</div><div class="special-name">å°ä¸‘</div>`;
      } else {
        const colorClass = SUIT_COLORS[card.suit];
        content = `<div class="rank ${colorClass}">${card.rank}</div><div class="suit ${colorClass}">${card.suit}</div>`;
      }
      
      const clickHandler = onClick && !disabled ? `onclick="${onClick}"` : '';
      
      return `<div class="card ${typeClass} ${sizeClass} ${selectedClass} ${disabledClass}" ${clickHandler}>${content}</div>`;
    }

    // æ¸²æŸ“ä¸»é¡µ
    function renderHome() {
      return `
        <div class="home-screen">
          <div class="home-card">
            <h1>ğŸ§™ å·«å¸ˆç‰Œ Online</h1>
            <p>ä¸æœ‹å‹ä»¬è”æœºå¯¹æˆ˜</p>

            <input type="text" id="playerNameInput" placeholder="è¾“å…¥ä½ çš„æ˜µç§°" maxlength="12" value="${playerName}">

            <button class="btn btn-primary" onclick="createRoom()">åˆ›å»ºæˆ¿é—´</button>

            <button class="btn btn-success" style="width: 100%; margin-top: 10px;" onclick="showAISetup()">ğŸ¤– äººæœºå¯¹æˆ˜</button>

            <div class="join-row" style="margin-top: 15px;">
              <input type="text" id="roomCodeInput" placeholder="æˆ¿é—´ç " maxlength="6">
              <button class="btn btn-success" onclick="joinRoom()">åŠ å…¥</button>
            </div>

            <div id="errorMsg" class="error-msg hidden"></div>

            <details>
              <summary>æ¸¸æˆè§„åˆ™</summary>
              <div style="margin-top: 10px; line-height: 1.6;">
                <p>â€¢ ç‰Œç»„ï¼š52å¼ æ‰‘å…‹ + 4å·«å¸ˆ + 4å°ä¸‘</p>
                <p>â€¢ å·«å¸ˆğŸ§™æœ€å¤§ï¼Œå°ä¸‘ğŸƒæœ€å°</p>
                <p>â€¢ æ¯è½®é¢„æµ‹èƒ½èµ¢å‡ å¢©</p>
                <p>â€¢ é¢„æµ‹æ­£ç¡® +20 + æ¯å¢©10åˆ†</p>
                <p>â€¢ é¢„æµ‹é”™è¯¯ -æ¯å·®ä¸€å¢©10åˆ†</p>
              </div>
            </details>
          </div>
        </div>
      `;
    }

    // æ¸²æŸ“ AI è®¾ç½®ç•Œé¢
    function renderAISetup() {
      return `
        <div class="home-screen">
          <div class="home-card">
            <h1>ğŸ¤– äººæœºå¯¹æˆ˜</h1>
            <p>è®¾ç½® AI å¯¹æ‰‹</p>

            <input type="text" id="aiPlayerNameInput" placeholder="è¾“å…¥ä½ çš„æ˜µç§°" maxlength="12" value="${playerName}">

            <div style="margin: 20px 0; text-align: left;">
              <label style="display: block; margin-bottom: 10px;">AI æ•°é‡ï¼š</label>
              <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn ${aiPlayerCount === 1 ? 'btn-primary' : 'btn-outline'}" onclick="setAICount(1)">1</button>
                <button class="btn ${aiPlayerCount === 2 ? 'btn-primary' : 'btn-outline'}" onclick="setAICount(2)">2</button>
                <button class="btn ${aiPlayerCount === 3 ? 'btn-primary' : 'btn-outline'}" onclick="setAICount(3)">3</button>
              </div>
            </div>

            <div style="margin: 20px 0; text-align: left;">
              <label style="display: block; margin-bottom: 10px;">AI éš¾åº¦ï¼š</label>
              <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn ${aiDifficulty === 'easy' ? 'btn-primary' : 'btn-outline'}" onclick="setAIDifficulty('easy')">ç®€å•</button>
                <button class="btn ${aiDifficulty === 'normal' ? 'btn-primary' : 'btn-outline'}" onclick="setAIDifficulty('normal')">æ™®é€š</button>
                <button class="btn ${aiDifficulty === 'hard' ? 'btn-primary' : 'btn-outline'}" onclick="setAIDifficulty('hard')">å›°éš¾</button>
              </div>
            </div>

            <button class="btn btn-success" style="width: 100%; margin-top: 20px;" onclick="startAIGame()">å¼€å§‹æ¸¸æˆ</button>
            <button class="btn btn-outline" style="width: 100%; margin-top: 10px;" onclick="backToHome()">è¿”å›</button>

            <div id="errorMsg" class="error-msg hidden"></div>
          </div>
        </div>
      `;
    }

    // AI è®¾ç½®ç›¸å…³å‡½æ•°
    let showingAISetup = false;

    function showAISetup() {
      playerName = document.getElementById('playerNameInput')?.value?.trim() || '';
      showingAISetup = true;
      render();
    }

    function backToHome() {
      showingAISetup = false;
      render();
    }

    function setAICount(count) {
      aiPlayerCount = count;
      render();
    }

    function setAIDifficulty(diff) {
      aiDifficulty = diff;
      render();
    }

    // å¼€å§‹ AI æ¸¸æˆ
    function startAIGame() {
      playerName = document.getElementById('aiPlayerNameInput')?.value?.trim() || '';
      if (!playerName) {
        showError('è¯·è¾“å…¥ä½ çš„æ˜µç§°');
        return;
      }

      isAIGame = true;
      showingAISetup = false;
      roomCode = 'AI-GAME';

      // éšæœºé€‰æ‹© AI åå­—
      const shuffledNames = [...AI_NAMES].sort(() => Math.random() - 0.5);

      // åˆ›å»ºæ¸¸æˆçŠ¶æ€
      const players = [{
        id: playerId,
        name: playerName,
        hand: [],
        bid: null,
        tricks: 0,
        score: 0,
        isHost: true,
        isAI: false,
      }];

      for (let i = 0; i < aiPlayerCount; i++) {
        players.push({
          id: `ai_${i}`,
          name: shuffledNames[i] || `AI ${i + 1}`,
          hand: [],
          bid: null,
          tricks: 0,
          score: 0,
          isHost: false,
          isAI: true,
        });
      }

      gameState = {
        roomCode: 'AI-GAME',
        phase: 'waiting',
        players,
        round: 0,
        dealer: 0,
        currentPlayer: 0,
        trumpCard: null,
        trumpSuit: null,
        currentTrick: [],
        leadSuit: null,
        seed: Date.now(),
      };

      myIndex = 0;

      // ç›´æ¥å¼€å§‹æ¸¸æˆ
      const newState = JSON.parse(JSON.stringify(gameState));
      newState.seed = Date.now();
      dealCards(newState, 1, 0);
      gameState = newState;
      myIndex = 0;

      render();

      // å¦‚æœä¸æ˜¯ç©å®¶å…ˆè¡ŒåŠ¨ï¼Œè§¦å‘ AI
      setTimeout(aiTakeTurn, 500);
    }

    // æ¸²æŸ“å¤§å…
    function renderLobby() {
      if (!gameState) return '<div class="lobby-screen"><div class="lobby-card">åŠ è½½ä¸­...</div></div>';
      
      const playersList = gameState.players.map((p, i) => `
        <div class="player-item ${p.id === playerId ? 'me' : ''}">
          <span>${p.name} ${p.id === playerId ? '(ä½ )' : ''}</span>
          ${p.isHost ? '<span class="host-badge">æˆ¿ä¸»</span>' : ''}
        </div>
      `).join('');
      
      const isHost = gameState.players[0]?.id === playerId;
      const canStart = gameState.players.length >= 2;
      
      return `
        <div class="lobby-screen">
          <div class="lobby-card">
            <h2>ç­‰å¾…ç©å®¶åŠ å…¥</h2>
            
            <div class="room-code-box">
              <div class="label">æˆ¿é—´ç </div>
              <div class="code">${roomCode}</div>
              <div class="hint">åˆ†äº«ç»™æœ‹å‹åŠ å…¥æ¸¸æˆ</div>
            </div>
            
            <div class="player-list">
              <div style="font-size: 14px; margin-bottom: 10px;">ç©å®¶ (${gameState.players.length}/4)</div>
              ${playersList}
            </div>
            
            ${isHost ? `
              <button class="btn btn-primary" onclick="startGame()" ${canStart ? '' : 'disabled'}>
                ${canStart ? 'å¼€å§‹æ¸¸æˆ' : 'ç­‰å¾…æ›´å¤šç©å®¶...'}
              </button>
            ` : `
              <div class="waiting-msg">ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ...</div>
            `}
            
            <button class="btn btn-outline" style="width: 100%; margin-top: 10px;" onclick="leaveRoom()">ç¦»å¼€æˆ¿é—´</button>
          </div>
        </div>
      `;
    }

    // æ¸²æŸ“æ¸¸æˆ
    function renderGame() {
      if (!gameState) return '<div class="container">åŠ è½½ä¸­...</div>';
      
      const numPlayers = gameState.players.length;
      const maxRounds = Math.floor(60 / numPlayers);
      const isMyTurn = myIndex === gameState.currentPlayer;
      const currentPlayerName = gameState.players[gameState.currentPlayer]?.name || '';
      
      // åˆ†æ•°æ¿
      const scoreBoard = gameState.players.map((p, i) => `
        <div class="player-score ${i === gameState.currentPlayer ? 'current' : ''} ${p.id === playerId ? 'me' : ''}">
          <div class="name">${p.name} ${p.id === playerId ? '(ä½ )' : ''}${p.isAI ? ' ğŸ¤–' : ''}</div>
          <div class="stats">åˆ†: ${p.score} | å«: ${p.bid !== null ? p.bid : '?'} | å¾—: ${p.tricks}</div>
        </div>
      `).join('');
      
      // å‡ºç‰ŒåŒº
      const trickCards = (gameState.currentTrick || []).map(play => `
        <div class="trick-card-wrapper">
          ${renderCard(play.card, { small: true })}
          <div class="player-name">${gameState.players[play.player]?.name}</div>
        </div>
      `).join('');
      
      // æ‰‹ç‰Œ
      const myHand = myIndex >= 0 ? (gameState.players[myIndex]?.hand || []) : [];
      const playableCards = getPlayableCards();
      const handCards = myHand.map((card, i) => {
        const isPlayable = playableCards.some(c => c.id === card.id);
        const isSelected = selectedCard?.id === card.id;
        const canClick = gameState.phase === 'playing' && isMyTurn && isPlayable;
        return renderCard(card, {
          selected: isSelected,
          disabled: !canClick,
          onClick: canClick ? `handleCardClick('${card.id}')` : null
        });
      }).join('');
      
      // å«ç‰ŒåŒº
      let bidArea = '';
      if (gameState.phase === 'bidding' && isMyTurn) {
        const totalBids = gameState.players.reduce((sum, p) => sum + (p.bid || 0), 0);
        const isLastBidder = myIndex === gameState.dealer;
        
        const bidButtons = Array.from({ length: gameState.round + 1 }, (_, i) => {
          const forbidden = isLastBidder && totalBids + i === gameState.round;
          return `<button class="bid-btn" onclick="handleBid(${i})" ${forbidden ? 'disabled' : ''} title="${forbidden ? 'æœ€åä¸€äººä¸èƒ½è®©æ€»é¢„æµ‹ç­‰äºç‰Œæ•°' : ''}">${i}</button>`;
        }).join('');
        
        bidArea = `
          <div class="bid-area">
            <div>è¯·é¢„æµ‹ä½ èƒ½èµ¢å‡ å¢©ï¼ˆ0-${gameState.round}ï¼‰ï¼š</div>
            <div class="bid-buttons">${bidButtons}</div>
          </div>
        `;
      }
      
      // è½®æ¬¡ç»“ç®—
      if (gameState.phase === 'roundEnd') {
        const isHost = gameState.players[0]?.id === playerId;
        const canContinue = isHost || isAIGame;
        const tableRows = gameState.players.map(p => {
          const roundScore = calculateScore(p.bid, p.tricks);
          const scoreClass = roundScore >= 0 ? 'positive' : 'negative';
          return `
            <tr class="${p.id === playerId ? 'me' : ''}">
              <td>${p.name}${p.isAI ? ' ğŸ¤–' : ''}</td>
              <td>${p.bid}</td>
              <td>${p.tricks}</td>
              <td class="${scoreClass}">${roundScore > 0 ? '+' : ''}${roundScore}</td>
              <td style="font-weight: bold;">${p.score}</td>
            </tr>
          `;
        }).join('');

        return `
          <div class="container">
            <div class="round-end">
              <h2>ç¬¬ ${gameState.round} è½®ç»“æŸ</h2>
              <table class="score-table">
                <thead>
                  <tr><th>ç©å®¶</th><th>é¢„æµ‹</th><th>å®é™…</th><th>æœ¬è½®</th><th>æ€»åˆ†</th></tr>
                </thead>
                <tbody>${tableRows}</tbody>
              </table>
              ${canContinue ? `
                <button class="btn btn-primary" style="margin-top: 30px;" onclick="nextRound()">
                  ${gameState.round >= maxRounds ? 'æŸ¥çœ‹æœ€ç»ˆç»“æœ' : 'ä¸‹ä¸€è½®'}
                </button>
              ` : '<div class="waiting-msg">ç­‰å¾…æˆ¿ä¸»ç»§ç»­...</div>'}
            </div>
          </div>
        `;
      }
      
      // æ¸¸æˆç»“æŸ
      if (gameState.phase === 'gameEnd') {
        const isHost = gameState.players[0]?.id === playerId;
        const canPlayAgain = isHost || isAIGame;
        const sorted = [...gameState.players].sort((a, b) => b.score - a.score);
        const rankings = sorted.map((p, i) => {
          const icons = ['ğŸ†', 'ğŸ¥ˆ', 'ğŸ¥‰', ''];
          return `
            <div class="rank-item ${i === 0 ? 'first' : ''} ${p.id === playerId ? 'me' : ''}">
              <span class="rank-icon">${icons[i] || ''}</span>
              <span class="rank-name">${p.name}${p.isAI ? ' ğŸ¤–' : ''}</span>
              <span class="rank-score">${p.score} åˆ†</span>
            </div>
          `;
        }).join('');

        return `
          <div class="container">
            <div class="game-end">
              <h2>ğŸ‰ æ¸¸æˆç»“æŸ ğŸ‰</h2>
              <div class="final-ranking">${rankings}</div>
              ${canPlayAgain ? '<button class="btn btn-primary" style="margin-top: 30px;" onclick="playAgain()">å†æ¥ä¸€å±€</button>' : ''}
              <button class="btn btn-outline" style="margin-top: 15px;" onclick="leaveRoom()">ç¦»å¼€æˆ¿é—´</button>
            </div>
          </div>
        `;
      }
      
      // æ­£å¸¸æ¸¸æˆç•Œé¢
      const trumpDisplay = gameState.trumpSuit 
        ? `<span class="trump-suit ${SUIT_COLORS[gameState.trumpSuit]}">${gameState.trumpSuit}</span>` 
        : 'æ— ';
      
      const modeLabel = isAIGame ? 'äººæœºå¯¹æˆ˜' : `æˆ¿é—´: ${roomCode}`;

      return `
        <div class="container">
          <div class="game-header">
            <h2 style="margin: 0;">ğŸ§™ å·«å¸ˆç‰Œ</h2>
            <div style="font-size: 14px; opacity: 0.8;">${modeLabel}</div>
          </div>
          
          <div class="info-bar">
            <div>ç¬¬ ${gameState.round} / ${maxRounds} è½®</div>
            <div>ç‹ç‰Œ: ${trumpDisplay}</div>
            <div class="turn-indicator ${isMyTurn ? 'my-turn' : ''} ${!isMyTurn && isAIGame && gameState.players[gameState.currentPlayer]?.isAI ? 'thinking' : ''}">
              ${isMyTurn ? 'ä½ çš„å›åˆ' : (isAIGame && gameState.players[gameState.currentPlayer]?.isAI ? `ğŸ¤– ${currentPlayerName} æ€è€ƒä¸­...` : `ç­‰å¾… ${currentPlayerName}`)}
            </div>
          </div>
          
          <div class="score-board">${scoreBoard}</div>
          
          <div class="trick-area">
            <div class="title">å‡ºç‰ŒåŒº</div>
            <div class="trick-cards">${trickCards}</div>
          </div>
          
          ${bidArea}
          
          <div class="hand-area">
            <div class="title">ä½ çš„æ‰‹ç‰Œ</div>
            <div class="hand-cards">${handCards}</div>
            ${gameState.phase === 'playing' && isMyTurn && selectedCard ? '<div class="play-hint">å†æ¬¡ç‚¹å‡»ç¡®è®¤å‡ºç‰Œ</div>' : ''}
          </div>
        </div>
      `;
    }

    // è·å–å¯å‡ºçš„ç‰Œ
    function getPlayableCards() {
      if (!gameState || gameState.phase !== 'playing' || myIndex !== gameState.currentPlayer) return [];
      
      const hand = gameState.players[myIndex]?.hand || [];
      if (!gameState.currentTrick || gameState.currentTrick.length === 0 || !gameState.leadSuit) return hand;
      
      const followCards = hand.filter(c => c.type === 'normal' && c.suit === gameState.leadSuit);
      if (followCards.length > 0) {
        return [...followCards, ...hand.filter(c => c.type !== 'normal')];
      }
      return hand;
    }

    // æ¸²æŸ“åº”ç”¨
    function render() {
      const app = document.getElementById('app');
      if (showingAISetup) {
        app.innerHTML = renderAISetup();
      } else if (!roomCode) {
        app.innerHTML = renderHome();
      } else if (!gameState || gameState.phase === 'waiting') {
        if (isAIGame) {
          app.innerHTML = renderGame();
        } else {
          app.innerHTML = renderLobby();
        }
      } else {
        app.innerHTML = renderGame();
      }
    }

    // æ˜¾ç¤ºé”™è¯¯
    function showError(msg) {
      const errorEl = document.getElementById('errorMsg');
      if (errorEl) {
        errorEl.textContent = msg;
        errorEl.classList.remove('hidden');
      } else {
        alert(msg);
      }
    }

    // åˆ›å»ºæˆ¿é—´
    async function createRoom() {
      playerName = document.getElementById('playerNameInput')?.value?.trim() || '';
      if (!playerName) {
        showError('è¯·è¾“å…¥ä½ çš„æ˜µç§°');
        return;
      }
      
      const code = generateRoomCode();
      const initialState = {
        roomCode: code,
        phase: 'waiting',
        players: [{
          id: playerId,
          name: playerName,
          hand: [],
          bid: null,
          tricks: 0,
          score: 0,
          isHost: true,
        }],
        round: 0,
        dealer: 0,
        currentPlayer: 0,
        trumpCard: null,
        trumpSuit: null,
        currentTrick: [],
        leadSuit: null,
        seed: Date.now(),
      };
      
      try {
        await db.ref(`rooms/${code}`).set(initialState);
        roomCode = code;
        subscribeToRoom();
        render();
      } catch (e) {
        showError('åˆ›å»ºæˆ¿é—´å¤±è´¥: ' + e.message);
      }
    }

    // åŠ å…¥æˆ¿é—´
    async function joinRoom() {
      playerName = document.getElementById('playerNameInput')?.value?.trim() || '';
      const inputCode = document.getElementById('roomCodeInput')?.value?.trim()?.toUpperCase() || '';
      
      if (!playerName) {
        showError('è¯·è¾“å…¥ä½ çš„æ˜µç§°');
        return;
      }
      if (!inputCode) {
        showError('è¯·è¾“å…¥æˆ¿é—´ç ');
        return;
      }
      
      try {
        const snapshot = await db.ref(`rooms/${inputCode}`).once('value');
        const state = snapshot.val();
        
        if (!state) {
          showError('æˆ¿é—´ä¸å­˜åœ¨');
          return;
        }
        
        if (state.phase !== 'waiting') {
          showError('æ¸¸æˆå·²ç»å¼€å§‹ï¼Œæ— æ³•åŠ å…¥');
          return;
        }
        
        if (state.players.length >= 4) {
          showError('æˆ¿é—´å·²æ»¡');
          return;
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²åœ¨æˆ¿é—´
        const existingIdx = state.players.findIndex(p => p.id === playerId);
        if (existingIdx >= 0) {
          state.players[existingIdx].name = playerName;
        } else {
          state.players.push({
            id: playerId,
            name: playerName,
            hand: [],
            bid: null,
            tricks: 0,
            score: 0,
            isHost: false,
          });
        }
        
        await db.ref(`rooms/${inputCode}`).set(state);
        roomCode = inputCode;
        subscribeToRoom();
        render();
      } catch (e) {
        showError('åŠ å…¥æˆ¿é—´å¤±è´¥: ' + e.message);
      }
    }

    // è®¢é˜…æˆ¿é—´æ›´æ–°
    function subscribeToRoom() {
      if (unsubscribe) unsubscribe();
      
      const roomRef = db.ref(`rooms/${roomCode}`);
      unsubscribe = () => roomRef.off();
      
      roomRef.on('value', (snapshot) => {
        gameState = snapshot.val();
        if (gameState) {
          myIndex = gameState.players.findIndex(p => p.id === playerId);
        }
        render();
      });
    }

    // å¼€å§‹æ¸¸æˆ
    async function startGame() {
      if (!gameState || gameState.players.length < 2) {
        showError('è‡³å°‘éœ€è¦2åç©å®¶');
        return;
      }
      
      const newState = JSON.parse(JSON.stringify(gameState));
      newState.seed = Date.now();
      dealCards(newState, 1, 0);
      
      await db.ref(`rooms/${roomCode}`).set(newState);
    }

    // å«ç‰Œ
    async function handleBid(bidAmount) {
      if (myIndex !== gameState.currentPlayer) return;

      const newState = JSON.parse(JSON.stringify(gameState));
      newState.players[myIndex].bid = bidAmount;

      const numPlayers = newState.players.length;

      if (newState.players.every(p => p.bid !== null)) {
        newState.phase = 'playing';
        newState.currentPlayer = (newState.dealer + 1) % numPlayers;
      } else {
        newState.currentPlayer = (newState.currentPlayer + 1) % numPlayers;
      }

      if (isAIGame) {
        gameState = newState;
        render();
        setTimeout(aiTakeTurn, 500);
      } else {
        await db.ref(`rooms/${roomCode}`).set(newState);
      }
    }

    // ç‚¹å‡»æ‰‹ç‰Œ
    function handleCardClick(cardId) {
      const hand = gameState.players[myIndex]?.hand || [];
      const card = hand.find(c => c.id === cardId);
      if (!card) return;
      
      if (selectedCard?.id === cardId) {
        handlePlay(card);
      } else {
        selectedCard = card;
        render();
      }
    }

    // å‡ºç‰Œ
    async function handlePlay(card) {
      if (myIndex !== gameState.currentPlayer) return;
      
      const newState = JSON.parse(JSON.stringify(gameState));
      const playerHand = newState.players[myIndex].hand;
      const cardIndex = playerHand.findIndex(c => c.id === card.id);
      
      if (cardIndex === -1) return;
      
      // æ£€æŸ¥è·Ÿç‰Œ
      const leadSuit = newState.leadSuit;
      if (leadSuit && card.type === 'normal' && card.suit !== leadSuit) {
        const hasLeadSuit = playerHand.some(c => c.type === 'normal' && c.suit === leadSuit);
        if (hasLeadSuit) {
          alert('å¿…é¡»è·Ÿç‰Œï¼');
          return;
        }
      }
      
      // å‡ºç‰Œ
      playerHand.splice(cardIndex, 1);
      if (!newState.currentTrick) newState.currentTrick = [];
      newState.currentTrick.push({ player: myIndex, card });
      
      // è®¾ç½®é¦–å‡ºèŠ±è‰²
      if (newState.currentTrick.length === 1) {
        newState.leadSuit = card.type === 'normal' ? card.suit : null;
      } else if (!newState.leadSuit && card.type === 'normal') {
        newState.leadSuit = card.suit;
      }
      
      const numPlayers = newState.players.length;
      
      // ä¸€å¢©ç»“æŸ
      if (newState.currentTrick.length === numPlayers) {
        const winnerIndex = determineTrickWinner(newState.currentTrick, newState.trumpSuit);
        const winner = newState.currentTrick[winnerIndex].player;
        newState.players[winner].tricks++;
        
        if (newState.players[0].hand.length === 0) {
          // è½®æ¬¡ç»“æŸ
          newState.players = newState.players.map(p => ({
            ...p,
            score: p.score + calculateScore(p.bid, p.tricks)
          }));
          newState.phase = 'roundEnd';
        } else {
          newState.currentTrick = [];
          newState.leadSuit = null;
          newState.currentPlayer = winner;
        }
      } else {
        newState.currentPlayer = (newState.currentPlayer + 1) % numPlayers;
      }
      
      selectedCard = null;

      if (isAIGame) {
        gameState = newState;
        render();
        setTimeout(aiTakeTurn, 500);
      } else {
        await db.ref(`rooms/${roomCode}`).set(newState);
      }
    }

    // ä¸‹ä¸€è½®
    async function nextRound() {
      const newState = JSON.parse(JSON.stringify(gameState));
      const numPlayers = newState.players.length;
      const maxRounds = Math.floor(60 / numPlayers);

      if (newState.round >= maxRounds) {
        newState.phase = 'gameEnd';
      } else {
        const newRound = newState.round + 1;
        const newDealer = (newState.dealer + 1) % numPlayers;
        newState.seed = Date.now();
        dealCards(newState, newRound, newDealer);
      }

      if (isAIGame) {
        gameState = newState;
        render();
        setTimeout(aiTakeTurn, 500);
      } else {
        await db.ref(`rooms/${roomCode}`).set(newState);
      }
    }

    // å†æ¥ä¸€å±€
    async function playAgain() {
      const newState = JSON.parse(JSON.stringify(gameState));
      newState.players = newState.players.map(p => ({
        ...p,
        hand: [],
        bid: null,
        tricks: 0,
        score: 0,
      }));

      if (isAIGame) {
        // AI æ¨¡å¼ç›´æ¥å¼€å§‹æ–°æ¸¸æˆ
        newState.seed = Date.now();
        dealCards(newState, 1, 0);
        gameState = newState;
        myIndex = 0;
        render();
        setTimeout(aiTakeTurn, 500);
      } else {
        newState.phase = 'waiting';
        newState.round = 0;
        newState.currentTrick = [];
        await db.ref(`rooms/${roomCode}`).set(newState);
      }
    }

    // ç¦»å¼€æˆ¿é—´
    function leaveRoom() {
      if (unsubscribe) unsubscribe();
      roomCode = '';
      gameState = null;
      myIndex = -1;
      selectedCard = null;
      isAIGame = false;
      showingAISetup = false;
      render();
    }

    // åˆå§‹åŒ–
    render();
  </script>
</body>
</html>
